import { IMG_CONTENT, IMG_CONTENT_WITHOUT_HASH } from "../../__tests__/utils";
import { Tiptap } from "../tiptap";

test("img src is empty after extract attachments", async () => {
  const tiptap = new Tiptap(IMG_CONTENT_WITHOUT_HASH);
  const result = await tiptap.extractAttachments(async () => {
    return { key: "hello", metadata: { hash: "helloworld" } };
  });
  expect(result.attachments).toHaveLength(1);
  expect(result.data).not.toContain(`src="data:image/png;`);
  expect(result.data).not.toContain(`src=`);
  expect(result.data).toContain(`data-hash="helloworld"`);
});

test("img src is present after insert attachments", async () => {
  const tiptap = new Tiptap(IMG_CONTENT);
  const result = await tiptap.extractAttachments(async () => {
    return { key: "hello", metadata: {} };
  });
  const tiptap2 = new Tiptap(result.data);
  const result2 = await tiptap2.insertMedia(() => "i am a data");
  expect(result2).toContain(`src="i am a data"`);
});

test("convert HTML to markdown with tables", async () => {
  const tiptap = new Tiptap(
    `<div><div class="table-container" contenteditable="false"><table style="border-collapse: collapse; width: 811px;" contenteditable="true" border="1" data-mce-selected="1"><tbody><tr data-mce-active="1"><td style="width: 81.375px;" data-mce-active="1">Goal</td><td style="width: 708.625px;">To introduce various features of the app to the user and to convert a user on trial or basic plan to upgrade.</td></tr><tr><td style="width: 81.375px;">Frequency</td><td style="width: 708.625px;">1/week or 2/week</td></tr><tr><td style="width: 81.375px;">Types</td><td style="width: 708.625px;">Feature intro, upgrade promo, one time emails</td></tr><tr><td style="width: 81.375px;"><br></td><td style="width: 708.625px;"><br></td></tr></tbody></table></div><h2>Emails</h2><h3>Feature intro</h3><p>Features:</p><ol style="list-style-type: decimal;"><li>Web clipper on mobile</li><li>Pin any note to notification</li><li>Take notes from notifications</li><li>App lock</li><li>Importer</li><li>Encrypted attachments</li><li>Session history &amp; automatic backups</li><li>Note publishing</li><li>Note exports<br data-mce-bogus="1"></li><li>Collapsible headers</li></ol><h3>Promos</h3><ol style="list-style-type: decimal;"><li>Trial about to end</li><li>Trial ending (with option to request an extension)</li><li>Try free for 14 days<br data-mce-bogus="1"></li></ol><h3>One time</h3><ol style="list-style-type: decimal;"><li>End-of-month progress report</li><li>What's coming/roadmap</li><li>What we are working on</li><li>Join the community<br data-mce-bogus="1"></li></ol><div id="mceResizeHandlenw" data-mce-bogus="all" class="mce-resizehandle" unselectable="true" data-mce-style="cursor: nw-resize; margin: 0px; padding: 0px; left: -6.5px; top: -6.5px;" style="cursor: nw-resize; margin: 0px; padding: 0px; left: -6.5px; top: -6.5px;"></div><div id="mceResizeHandlene" data-mce-bogus="all" class="mce-resizehandle" unselectable="true" data-mce-style="cursor: ne-resize; margin: 0px; padding: 0px; left: 856.5px; top: -6.5px;" style="cursor: ne-resize; margin: 0px; padding: 0px; left: 856.5px; top: -6.5px;"></div><div id="mceResizeHandlese" data-mce-bogus="all" class="mce-resizehandle" unselectable="true" data-mce-style="cursor: se-resize; margin: 0px; padding: 0px; left: 856.5px; top: 117.9px;" style="cursor: se-resize; margin: 0px; padding: 0px; left: 856.5px; top: 117.9px;"></div><div id="mceResizeHandlesw" data-mce-bogus="all" class="mce-resizehandle" unselectable="true" data-mce-style="cursor: sw-resize; margin: 0px; padding: 0px; left: -6.5px; top: 117.9px;" style="cursor: sw-resize; margin: 0px; padding: 0px; left: -6.5px; top: 117.9px;"></div></div>`
  );
  expect(tiptap.toMD()).toMatchSnapshot("html-to-md-tables.md");
});

test("convert HTML to markdown with code blocks", async () => {
  const tiptap = new Tiptap(
    `<div id="a94ae3f0aa12ec57d06ed845" class="mce-content-body mce-edit-focus" contenteditable="true" style="position: relative;"><p>Typescript is one of those languages that appear to be very simple. It's often described as "Javascript with types" and it fits that name very well. However, what many don't realize starting out with Typescript is that Typescript&nbsp;<em>is </em>a language and like all other languages it has it's own "secrets", it's own set of quirks.</p><p>When I started out with Typescript a few years back, I absolutely hated it. It was unnecessary, a box of clutter, making me write code that would never actually run. I hated defining interfaces, typing out all my functions, and thinking in terms I was not used to as a Javascript developer. Before Javascript, I had coded in C# and I had never really liked C# (I still don't) mostly for the huge amounts of boilerplate and magic involved. Typescript is heavily inspired by C# and seeing that contaminate the Javascript ecosystem irked me no end.</p><p>That was all just fluff. Typescript is a great language solving a considerable amount of problems for a huge amount of developers. And generics is the hidden weapon behind it all.</p><h2 class="">Understanding Typescript generics</h2><p class="">For all points and purposes, generics shouldn't exist. They are one of the main factors behind abysmal code readability. But in the right hands, generics turn into a super-weapon.</p><p class="">The main problem generics try to solve is how to take in multiple types of parameters. This is a solved problem but requires duplicating your functions or using conditions to separate out different logic for different types. That is essentially what generics do as well but hidden from human eyes.</p><p class="">Think of a container that can take any type of item as long as it is not a circle. In Javascript, this becomes a problem you have to solve at runtime with checks &amp; conditions:</p><pre class="hljs language-javascript" spellcheck="false"><span class="hljs-keyword">var</span> container = [];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">putIntoContainer</span>(<span class="hljs-params">item</span>) {<br>&nbsp; &nbsp; <span class="hljs-keyword">if</span> (item.<span class="hljs-property">type</span> === <span class="hljs-string">"round"</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Rounded items not supported."</span>)<br>&nbsp; &nbsp; container.<span class="hljs-title function_">push</span>(item);<br>}<br><br><span class="hljs-keyword">var</span> square = {<span class="hljs-attr">type</span>: <span class="hljs-string">"square"</span>}<br><span class="hljs-keyword">var</span> circle = {<span class="hljs-attr">type</span>: <span class="hljs-string">"round"</span>}<br><span class="hljs-title function_">putIntoContainer</span>(square)<br><span class="hljs-title function_">putIntoContainer</span>(circle) <span class="hljs-comment">// ERROR! Rounded items not supported!</span><br></pre><p class="">There are many ways to solve this problem and some are even practical. The issue here isn't of repetition but of doing unnecessary work. Type safe languages would automatically give an error if there was a wrong type but Javascript knows nothing about the <code spellcheck="false">item</code>.</p><p class="">In Typescript, this will be solved much more succinctly:</p><pre class="hljs language-typescript" spellcheck="false"><span class="hljs-comment">// first define the types of items we'll handle</span><br><span class="hljs-comment">// i.e. we don't want to handle any item other</span><br><span class="hljs-comment">// than square or round.</span><br><span class="hljs-comment">// This gives us nice auto completion and safety</span><br><span class="hljs-comment">// against typos.</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ItemTypes</span> = <span class="hljs-string">"square"</span> | <span class="hljs-string">"round"</span>;<br><br><span class="hljs-comment">// Define a generic item that can be of any type</span><br><span class="hljs-comment">// defined in ItemTypes.</span><br><span class="hljs-comment">// i.e. Item&lt;"triangle"&gt; will give an error.</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>&lt;TItemType <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ItemTypes</span>&gt; = {<br>&nbsp;<span class="hljs-keyword">type</span>?: TItemType;<br>&nbsp;<span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>&nbsp;<span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>};<br><br><span class="hljs-comment">// This is just syntax sugar to increase readability.</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Square</span> = <span class="hljs-title class_">Item</span>&lt;<span class="hljs-string">"square"</span>&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Circle</span> = <span class="hljs-title class_">Item</span>&lt;<span class="hljs-string">"round"</span>&gt;;<br><br><span class="hljs-comment">// Our container is just a simple wrapper around an array</span><br><span class="hljs-comment">// that accepts items of only a specific type.</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Container</span>&lt;TItemType <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ItemTypes</span>&gt; = <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Item</span>&lt;TItemType&gt;&gt;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-attr">squareContainer</span>: <span class="hljs-title class_">Container</span>&lt;<span class="hljs-string">"square"</span>&gt; = [];<br><span class="hljs-keyword">var</span> <span class="hljs-attr">roundContainer</span>: <span class="hljs-title class_">Container</span>&lt;<span class="hljs-string">"round"</span>&gt; = [];<br><br><span class="hljs-comment">// This wrapper is unnecessary, of course, because array.push</span><br><span class="hljs-comment">// already does this. Only for demonstration purposes.</span><br><span class="hljs-keyword">function</span> putIntoContainer&lt;<br>&nbsp;TItemType <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ItemTypes</span>,<br>&nbsp;TItem <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Item</span>&lt;TItemType&gt;<br>&gt;(<span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span>&lt;TItemType&gt;, <span class="hljs-attr">item</span>: TItem) {<br>&nbsp;container.<span class="hljs-title function_">push</span>(item);<br>}<br><br><span class="hljs-keyword">var</span> <span class="hljs-attr">square</span>: <span class="hljs-title class_">Square</span> = { <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">200</span> };<br><span class="hljs-keyword">var</span> <span class="hljs-attr">circle</span>: <span class="hljs-title class_">Circle</span> = { <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">500</span> };<br><br><span class="hljs-title function_">putIntoContainer</span>(squareContainer, square);<br><span class="hljs-title function_">putIntoContainer</span>(roundContainer, circle);<br><span class="hljs-title function_">putIntoContainer</span>(roundContainer, square); <span class="hljs-comment">// Error: Argument of type 'Square' is not assignable to parameter of type 'Item&lt;"round"&gt;'.</span><br><span class="hljs-title function_">putIntoContainer</span>(squareContainer, circle); <span class="hljs-comment">// Error: Argument of type 'Circle' is not assignable to parameter of type 'Item&lt;"square"&gt;'.</span><br></pre><p class="">A lot more code, I know, and if you don't know how generics work that blob of code is utter nonsense. One of the main reasons I avoided Typescript for a long time. But look at the benefits:</p><ol style="list-style-type: decimal;" class=""><li>You have 100% compile-time type safety.</li><li>You can't put a round item in a square container (you will get compiler error).<br></li><li>You didn't write any extra runtime code.</li></ol><p class="">Expanding on point #3, after transpilation the above code will turn more-or-less into:</p><pre class="hljs language-javascript" spellcheck="false"><span class="hljs-keyword">var</span> squareContainer = [];<br><span class="hljs-keyword">var</span> roundContainer = [];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">putIntoContainer</span>(<span class="hljs-params">container, item</span>) {<br>&nbsp;container.<span class="hljs-title function_">push</span>(item);<br>}<br><br><span class="hljs-keyword">var</span> square = { <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">200</span> };<br><span class="hljs-keyword">var</span> circle = { <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">500</span> };<br><br><span class="hljs-title function_">putIntoContainer</span>(squareContainer, square);<br><span class="hljs-title function_">putIntoContainer</span>(roundContainer, circle);<br></pre><p class="">This is the power of generics. More specifically, this is Typescript generics at a glance.</p><p class="">But this post was supposed to be about the "Secrets" of Typescript Generics, right? Well, let's get into that.</p><h2 class="">1. Type filters using ternary operators</h2><h2>2. Deeply recursive types</h2><h2>3. Type functions</h2><h2>4. Type inference using interface properties</h2><p><br></p></div>`
  );
  expect(tiptap.toMD()).toMatchSnapshot("html-to-md-codeblock.md");
});
